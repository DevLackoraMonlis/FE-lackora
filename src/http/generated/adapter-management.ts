/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * MonoWatch BackBone
 * MonoWatch Security Asset Management
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AdapterValidationResponse,
  AdaptersDependencyCheckResponse,
  BodyImportAdapterAdp,
  BodyValidateAdapterAdp,
  GetAdaptersParams,
  HTTPValidationError,
  MessageOnlyResponse,
  PaginatedBaseResponseEachAdapterInformationEachListMetadataWrapper
} from './models';

import { orvalMutator } from '../orval-mutator';





/**
 * @summary Validate Adapter Adp File
 */
export const validateAdapterAdp = (
    bodyValidateAdapterAdp: BodyValidateAdapterAdp,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append("file", bodyValidateAdapterAdp.file)

      return orvalMutator<AdapterValidationResponse>(
      {url: "/api/adapter-management/validate-adp", method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getValidateAdapterAdpMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateAdapterAdp>>, TError,{data: BodyValidateAdapterAdp}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof validateAdapterAdp>>, TError,{data: BodyValidateAdapterAdp}, TContext> => {

const mutationKey = ['validateAdapterAdp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateAdapterAdp>>, {data: BodyValidateAdapterAdp}> = (props) => {
          const {data} = props ?? {};

          return  validateAdapterAdp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateAdapterAdpMutationResult = NonNullable<Awaited<ReturnType<typeof validateAdapterAdp>>>
    export type ValidateAdapterAdpMutationBody = BodyValidateAdapterAdp
    export type ValidateAdapterAdpMutationError = HTTPValidationError

    /**
 * @summary Validate Adapter Adp File
 */
export const useValidateAdapterAdp = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateAdapterAdp>>, TError,{data: BodyValidateAdapterAdp}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateAdapterAdp>>,
        TError,
        {data: BodyValidateAdapterAdp},
        TContext
      > => {

      const mutationOptions = getValidateAdapterAdpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Import Adapter Adp File
 */
export const importAdapterAdp = (
    bodyImportAdapterAdp: BodyImportAdapterAdp,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append("file", bodyImportAdapterAdp.file)

      return orvalMutator<AdapterValidationResponse>(
      {url: "/api/adapter-management/import-adp", method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getImportAdapterAdpMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importAdapterAdp>>, TError,{data: BodyImportAdapterAdp}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof importAdapterAdp>>, TError,{data: BodyImportAdapterAdp}, TContext> => {

const mutationKey = ['importAdapterAdp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof importAdapterAdp>>, {data: BodyImportAdapterAdp}> = (props) => {
          const {data} = props ?? {};

          return  importAdapterAdp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImportAdapterAdpMutationResult = NonNullable<Awaited<ReturnType<typeof importAdapterAdp>>>
    export type ImportAdapterAdpMutationBody = BodyImportAdapterAdp
    export type ImportAdapterAdpMutationError = HTTPValidationError

    /**
 * @summary Import Adapter Adp File
 */
export const useImportAdapterAdp = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importAdapterAdp>>, TError,{data: BodyImportAdapterAdp}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof importAdapterAdp>>,
        TError,
        {data: BodyImportAdapterAdp},
        TContext
      > => {

      const mutationOptions = getImportAdapterAdpMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary List All Adapters
 */
export const getAdapters = (
    params?: GetAdaptersParams,
 signal?: AbortSignal
) => {
      
      
      return orvalMutator<PaginatedBaseResponseEachAdapterInformationEachListMetadataWrapper>(
      {url: "/api/adapter-management/", method: 'GET',
        params, signal
    },
      );
    }
  

const getGetAdaptersQueryKey = (params?: GetAdaptersParams,) => {
    return ["/api/adapter-management/", ...(params ? [params]: [])] as const;
    }

    
export const getGetAdaptersQueryOptions = <TData = Awaited<ReturnType<typeof getAdapters>>, TError = HTTPValidationError>(params?: GetAdaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdaptersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdapters>>> = ({ signal }) => getAdapters(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdaptersQueryResult = NonNullable<Awaited<ReturnType<typeof getAdapters>>>
export type GetAdaptersQueryError = HTTPValidationError


export function useGetAdapters<TData = Awaited<ReturnType<typeof getAdapters>>, TError = HTTPValidationError>(
 params: undefined |  GetAdaptersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdapters>>,
          TError,
          Awaited<ReturnType<typeof getAdapters>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdapters<TData = Awaited<ReturnType<typeof getAdapters>>, TError = HTTPValidationError>(
 params?: GetAdaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdapters>>,
          TError,
          Awaited<ReturnType<typeof getAdapters>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdapters<TData = Awaited<ReturnType<typeof getAdapters>>, TError = HTTPValidationError>(
 params?: GetAdaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List All Adapters
 */

export function useGetAdapters<TData = Awaited<ReturnType<typeof getAdapters>>, TError = HTTPValidationError>(
 params?: GetAdaptersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapters>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdaptersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Adapter Dependency
 */
export const getAdapterDependency = (
    adapterId: string,
 signal?: AbortSignal
) => {
      
      
      return orvalMutator<AdaptersDependencyCheckResponse>(
      {url: `/api/adapter-management/${adapterId}/dependency`, method: 'GET', signal
    },
      );
    }
  

const getGetAdapterDependencyQueryKey = (adapterId: string,) => {
    return [`/api/adapter-management/${adapterId}/dependency`] as const;
    }

    
export const getGetAdapterDependencyQueryOptions = <TData = Awaited<ReturnType<typeof getAdapterDependency>>, TError = HTTPValidationError>(adapterId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdapterDependencyQueryKey(adapterId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdapterDependency>>> = ({ signal }) => getAdapterDependency(adapterId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(adapterId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAdapterDependencyQueryResult = NonNullable<Awaited<ReturnType<typeof getAdapterDependency>>>
export type GetAdapterDependencyQueryError = HTTPValidationError


export function useGetAdapterDependency<TData = Awaited<ReturnType<typeof getAdapterDependency>>, TError = HTTPValidationError>(
 adapterId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdapterDependency>>,
          TError,
          Awaited<ReturnType<typeof getAdapterDependency>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdapterDependency<TData = Awaited<ReturnType<typeof getAdapterDependency>>, TError = HTTPValidationError>(
 adapterId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdapterDependency>>,
          TError,
          Awaited<ReturnType<typeof getAdapterDependency>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAdapterDependency<TData = Awaited<ReturnType<typeof getAdapterDependency>>, TError = HTTPValidationError>(
 adapterId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Adapter Dependency
 */

export function useGetAdapterDependency<TData = Awaited<ReturnType<typeof getAdapterDependency>>, TError = HTTPValidationError>(
 adapterId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdapterDependency>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAdapterDependencyQueryOptions(adapterId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete Single Adapter
 */
export const deleteAdapter = (
    adapterId: string,
 ) => {
      
      
      return orvalMutator<MessageOnlyResponse>(
      {url: `/api/adapter-management/${adapterId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAdapterMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdapter>>, TError,{adapterId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAdapter>>, TError,{adapterId: string}, TContext> => {

const mutationKey = ['deleteAdapter'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAdapter>>, {adapterId: string}> = (props) => {
          const {adapterId} = props ?? {};

          return  deleteAdapter(adapterId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAdapterMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAdapter>>>
    
    export type DeleteAdapterMutationError = HTTPValidationError

    /**
 * @summary Delete Single Adapter
 */
export const useDeleteAdapter = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAdapter>>, TError,{adapterId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAdapter>>,
        TError,
        {adapterId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAdapterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
